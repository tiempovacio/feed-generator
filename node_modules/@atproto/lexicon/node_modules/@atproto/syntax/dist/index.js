"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  ATP_URI_REGEX: () => ATP_URI_REGEX,
  AtUri: () => AtUri,
  DISALLOWED_TLDS: () => DISALLOWED_TLDS,
  DisallowedDomainError: () => DisallowedDomainError,
  INVALID_HANDLE: () => INVALID_HANDLE,
  InvalidDatetimeError: () => InvalidDatetimeError,
  InvalidDidError: () => InvalidDidError,
  InvalidHandleError: () => InvalidHandleError,
  InvalidNsidError: () => InvalidNsidError,
  InvalidRecordKeyError: () => InvalidRecordKeyError,
  InvalidTidError: () => InvalidTidError,
  NSID: () => NSID,
  ReservedHandleError: () => ReservedHandleError,
  UnsupportedDomainError: () => UnsupportedDomainError,
  ensureValidAtUri: () => ensureValidAtUri,
  ensureValidAtUriRegex: () => ensureValidAtUriRegex,
  ensureValidDatetime: () => ensureValidDatetime,
  ensureValidDid: () => ensureValidDid,
  ensureValidDidRegex: () => ensureValidDidRegex,
  ensureValidHandle: () => ensureValidHandle,
  ensureValidHandleRegex: () => ensureValidHandleRegex,
  ensureValidNsid: () => ensureValidNsid,
  ensureValidNsidRegex: () => ensureValidNsidRegex,
  ensureValidRecordKey: () => ensureValidRecordKey,
  ensureValidTid: () => ensureValidTid,
  isValidDatetime: () => isValidDatetime,
  isValidHandle: () => isValidHandle,
  isValidRecordKey: () => isValidRecordKey,
  isValidTid: () => isValidTid,
  isValidTld: () => isValidTld,
  normalizeAndEnsureValidHandle: () => normalizeAndEnsureValidHandle,
  normalizeDatetime: () => normalizeDatetime,
  normalizeDatetimeAlways: () => normalizeDatetimeAlways,
  normalizeHandle: () => normalizeHandle
});
module.exports = __toCommonJS(src_exports);

// src/handle.ts
var INVALID_HANDLE = "handle.invalid";
var DISALLOWED_TLDS = [
  ".local",
  ".arpa",
  ".invalid",
  ".localhost",
  ".internal",
  ".example",
  ".alt",
  ".onion"
];
var ensureValidHandle = (handle) => {
  if (!/^[a-zA-Z0-9.-]*$/.test(handle)) {
    throw new InvalidHandleError("Disallowed characters in handle (ASCII letters, digits, dashes, periods only)");
  }
  if (handle.length > 253) {
    throw new InvalidHandleError("Handle is too long (253 chars max)");
  }
  const labels = handle.split(".");
  if (labels.length < 2) {
    throw new InvalidHandleError("Handle domain needs at least two parts");
  }
  for (let i = 0; i < labels.length; i++) {
    const l = labels[i];
    if (l.length < 1) {
      throw new InvalidHandleError("Handle parts can not be empty");
    }
    if (l.length > 63) {
      throw new InvalidHandleError("Handle part too long (max 63 chars)");
    }
    if (l.endsWith("-") || l.startsWith("-")) {
      throw new InvalidHandleError("Handle parts can not start or end with hyphens");
    }
    if (i + 1 == labels.length && !/^[a-zA-Z]/.test(l)) {
      throw new InvalidHandleError("Handle final component (TLD) must start with ASCII letter");
    }
  }
};
var ensureValidHandleRegex = (handle) => {
  if (!/^([a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?$/.test(handle)) {
    throw new InvalidHandleError("Handle didn't validate via regex");
  }
  if (handle.length > 253) {
    throw new InvalidHandleError("Handle is too long (253 chars max)");
  }
};
var normalizeHandle = (handle) => {
  return handle.toLowerCase();
};
var normalizeAndEnsureValidHandle = (handle) => {
  const normalized = normalizeHandle(handle);
  ensureValidHandle(normalized);
  return normalized;
};
var isValidHandle = (handle) => {
  try {
    ensureValidHandle(handle);
  } catch (err) {
    if (err instanceof InvalidHandleError) {
      return false;
    }
    throw err;
  }
  return true;
};
var isValidTld = (handle) => {
  return !DISALLOWED_TLDS.some((domain) => handle.endsWith(domain));
};
var InvalidHandleError = class extends Error {
};
var ReservedHandleError = class extends Error {
};
var UnsupportedDomainError = class extends Error {
};
var DisallowedDomainError = class extends Error {
};

// src/did.ts
var ensureValidDid = (did) => {
  if (!/^[a-zA-Z0-9._:%-]*$/.test(did)) {
    throw new InvalidDidError("Disallowed characters in DID (ASCII letters, digits, and a couple other characters only)");
  }
  const parts = did.split(":");
  if (parts.length < 3) {
    throw new InvalidDidError("DID requires prefix, method, and method-specific content");
  }
  if (parts[0] != "did") {
    throw new InvalidDidError('DID requires "did:" prefix');
  }
  if (!/^[a-z]+$/.test(parts[1])) {
    throw new InvalidDidError("DID method must be lower-case letters");
  }
  if (did.endsWith(":") || did.endsWith("%")) {
    throw new InvalidDidError('DID can not end with ":" or "%"');
  }
  if (did.length > 2 * 1024) {
    throw new InvalidDidError("DID is too long (2048 chars max)");
  }
};
var ensureValidDidRegex = (did) => {
  if (!/^did:[a-z]+:[a-zA-Z0-9._:%-]*[a-zA-Z0-9._-]$/.test(did)) {
    throw new InvalidDidError("DID didn't validate via regex");
  }
  if (did.length > 2 * 1024) {
    throw new InvalidDidError("DID is too long (2048 chars max)");
  }
};
var InvalidDidError = class extends Error {
};

// src/nsid.ts
var NSID = class {
  constructor(nsid) {
    this.segments = [];
    ensureValidNsid(nsid);
    this.segments = nsid.split(".");
  }
  static parse(nsid) {
    return new NSID(nsid);
  }
  static create(authority, name) {
    const segments = [...authority.split(".").reverse(), name].join(".");
    return new NSID(segments);
  }
  static isValid(nsid) {
    try {
      NSID.parse(nsid);
      return true;
    } catch (e) {
      return false;
    }
  }
  get authority() {
    return this.segments.slice(0, this.segments.length - 1).reverse().join(".");
  }
  get name() {
    return this.segments.at(this.segments.length - 1);
  }
  toString() {
    return this.segments.join(".");
  }
};
var ensureValidNsid = (nsid) => {
  const toCheck = nsid;
  if (!/^[a-zA-Z0-9.-]*$/.test(toCheck)) {
    throw new InvalidNsidError("Disallowed characters in NSID (ASCII letters, digits, dashes, periods only)");
  }
  if (toCheck.length > 253 + 1 + 63) {
    throw new InvalidNsidError("NSID is too long (317 chars max)");
  }
  const labels = toCheck.split(".");
  if (labels.length < 3) {
    throw new InvalidNsidError("NSID needs at least three parts");
  }
  for (let i = 0; i < labels.length; i++) {
    const l = labels[i];
    if (l.length < 1) {
      throw new InvalidNsidError("NSID parts can not be empty");
    }
    if (l.length > 63) {
      throw new InvalidNsidError("NSID part too long (max 63 chars)");
    }
    if (l.endsWith("-") || l.startsWith("-")) {
      throw new InvalidNsidError("NSID parts can not start or end with hyphen");
    }
    if (/^[0-9]/.test(l) && i == 0) {
      throw new InvalidNsidError("NSID first part may not start with a digit");
    }
    if (!/^[a-zA-Z]+$/.test(l) && i + 1 == labels.length) {
      throw new InvalidNsidError("NSID name part must be only letters");
    }
  }
};
var ensureValidNsidRegex = (nsid) => {
  if (!/^[a-zA-Z]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(\.[a-zA-Z]([a-zA-Z]{0,61}[a-zA-Z])?)$/.test(nsid)) {
    throw new InvalidNsidError("NSID didn't validate via regex");
  }
  if (nsid.length > 253 + 1 + 63) {
    throw new InvalidNsidError("NSID is too long (317 chars max)");
  }
};
var InvalidNsidError = class extends Error {
};

// src/aturi_validation.ts
var ensureValidAtUri = (uri) => {
  const uriParts = uri.split("#");
  if (uriParts.length > 2) {
    throw new Error('ATURI can have at most one "#", separating fragment out');
  }
  const fragmentPart = uriParts[1] || null;
  uri = uriParts[0];
  if (!/^[a-zA-Z0-9._~:@!$&')(*+,;=%/-]*$/.test(uri)) {
    throw new Error("Disallowed characters in ATURI (ASCII)");
  }
  const parts = uri.split("/");
  if (parts.length >= 3 && (parts[0] != "at:" || parts[1].length != 0)) {
    throw new Error('ATURI must start with "at://"');
  }
  if (parts.length < 3) {
    throw new Error("ATURI requires at least method and authority sections");
  }
  try {
    if (parts[2].startsWith("did:")) {
      ensureValidDid(parts[2]);
    } else {
      ensureValidHandle(parts[2]);
    }
  } catch {
    throw new Error("ATURI authority must be a valid handle or DID");
  }
  if (parts.length >= 4) {
    if (parts[3].length == 0) {
      throw new Error("ATURI can not have a slash after authority without a path segment");
    }
    try {
      ensureValidNsid(parts[3]);
    } catch {
      throw new Error("ATURI requires first path segment (if supplied) to be valid NSID");
    }
  }
  if (parts.length >= 5) {
    if (parts[4].length == 0) {
      throw new Error("ATURI can not have a slash after collection, unless record key is provided");
    }
  }
  if (parts.length >= 6) {
    throw new Error("ATURI path can have at most two parts, and no trailing slash");
  }
  if (uriParts.length >= 2 && fragmentPart == null) {
    throw new Error("ATURI fragment must be non-empty and start with slash");
  }
  if (fragmentPart != null) {
    if (fragmentPart.length == 0 || fragmentPart[0] != "/") {
      throw new Error("ATURI fragment must be non-empty and start with slash");
    }
    if (!/^\/[a-zA-Z0-9._~:@!$&')(*+,;=%[\]/-]*$/.test(fragmentPart)) {
      throw new Error("Disallowed characters in ATURI fragment (ASCII)");
    }
  }
  if (uri.length > 8 * 1024) {
    throw new Error("ATURI is far too long");
  }
};
var ensureValidAtUriRegex = (uri) => {
  const aturiRegex = /^at:\/\/(?<authority>[a-zA-Z0-9._:%-]+)(\/(?<collection>[a-zA-Z0-9-.]+)(\/(?<rkey>[a-zA-Z0-9._~:@!$&%')(*+,;=-]+))?)?(#(?<fragment>\/[a-zA-Z0-9._~:@!$&%')(*+,;=\-[\]/\\]*))?$/;
  const rm = uri.match(aturiRegex);
  if (!rm || !rm.groups) {
    throw new Error("ATURI didn't validate via regex");
  }
  const groups = rm.groups;
  try {
    ensureValidHandleRegex(groups.authority);
  } catch {
    try {
      ensureValidDidRegex(groups.authority);
    } catch {
      throw new Error("ATURI authority must be a valid handle or DID");
    }
  }
  if (groups.collection) {
    try {
      ensureValidNsidRegex(groups.collection);
    } catch {
      throw new Error("ATURI collection path segment must be a valid NSID");
    }
  }
  if (uri.length > 8 * 1024) {
    throw new Error("ATURI is far too long");
  }
};

// src/aturi.ts
var ATP_URI_REGEX = /^(at:\/\/)?((?:did:[a-z0-9:%-]+)|(?:[a-z0-9][a-z0-9.:-]*))(\/[^?#\s]*)?(\?[^#\s]+)?(#[^\s]+)?$/i;
var RELATIVE_REGEX = /^(\/[^?#\s]*)?(\?[^#\s]+)?(#[^\s]+)?$/i;
var AtUri = class {
  constructor(uri, base) {
    let parsed;
    if (base) {
      parsed = parse(base);
      if (!parsed) {
        throw new Error(`Invalid at uri: ${base}`);
      }
      const relativep = parseRelative(uri);
      if (!relativep) {
        throw new Error(`Invalid path: ${uri}`);
      }
      Object.assign(parsed, relativep);
    } else {
      parsed = parse(uri);
      if (!parsed) {
        throw new Error(`Invalid at uri: ${uri}`);
      }
    }
    this.hash = parsed.hash;
    this.host = parsed.host;
    this.pathname = parsed.pathname;
    this.searchParams = parsed.searchParams;
  }
  static make(handleOrDid, collection, rkey) {
    let str = handleOrDid;
    if (collection)
      str += "/" + collection;
    if (rkey)
      str += "/" + rkey;
    return new AtUri(str);
  }
  get protocol() {
    return "at:";
  }
  get origin() {
    return `at://${this.host}`;
  }
  get hostname() {
    return this.host;
  }
  set hostname(v) {
    this.host = v;
  }
  get search() {
    return this.searchParams.toString();
  }
  set search(v) {
    this.searchParams = new URLSearchParams(v);
  }
  get collection() {
    return this.pathname.split("/").filter(Boolean)[0] || "";
  }
  set collection(v) {
    const parts = this.pathname.split("/").filter(Boolean);
    parts[0] = v;
    this.pathname = parts.join("/");
  }
  get rkey() {
    return this.pathname.split("/").filter(Boolean)[1] || "";
  }
  set rkey(v) {
    const parts = this.pathname.split("/").filter(Boolean);
    if (!parts[0])
      parts[0] = "undefined";
    parts[1] = v;
    this.pathname = parts.join("/");
  }
  get href() {
    return this.toString();
  }
  toString() {
    let path = this.pathname || "/";
    if (!path.startsWith("/")) {
      path = `/${path}`;
    }
    let qs = this.searchParams.toString();
    if (qs && !qs.startsWith("?")) {
      qs = `?${qs}`;
    }
    let hash = this.hash;
    if (hash && !hash.startsWith("#")) {
      hash = `#${hash}`;
    }
    return `at://${this.host}${path}${qs}${hash}`;
  }
};
function parse(str) {
  const match = ATP_URI_REGEX.exec(str);
  if (match) {
    return {
      hash: match[5] || "",
      host: match[2] || "",
      pathname: match[3] || "",
      searchParams: new URLSearchParams(match[4] || "")
    };
  }
  return void 0;
}
function parseRelative(str) {
  const match = RELATIVE_REGEX.exec(str);
  if (match) {
    return {
      hash: match[3] || "",
      pathname: match[1] || "",
      searchParams: new URLSearchParams(match[2] || "")
    };
  }
  return void 0;
}

// src/tid.ts
var ensureValidTid = (tid) => {
  if (tid.length != 13) {
    throw new InvalidTidError("TID must be 13 characters");
  }
  if (!/^[234567abcdefghij][234567abcdefghijklmnopqrstuvwxyz]{12}$/.test(tid)) {
    throw new InvalidTidError("TID syntax not valid (regex)");
  }
};
var isValidTid = (tid) => {
  try {
    ensureValidTid(tid);
  } catch (err) {
    if (err instanceof InvalidTidError) {
      return false;
    }
    throw err;
  }
  return true;
};
var InvalidTidError = class extends Error {
};

// src/recordkey.ts
var ensureValidRecordKey = (rkey) => {
  if (rkey.length > 512 || rkey.length < 1) {
    throw new InvalidRecordKeyError("record key must be 1 to 512 characters");
  }
  if (!/^[a-zA-Z0-9_~.:-]{1,512}$/.test(rkey)) {
    throw new InvalidRecordKeyError("record key syntax not valid (regex)");
  }
  if (rkey == "." || rkey == "..")
    throw new InvalidRecordKeyError('record key can not be "." or ".."');
};
var isValidRecordKey = (rkey) => {
  try {
    ensureValidRecordKey(rkey);
  } catch (err) {
    if (err instanceof InvalidRecordKeyError) {
      return false;
    }
    throw err;
  }
  return true;
};
var InvalidRecordKeyError = class extends Error {
};

// src/datetime.ts
var ensureValidDatetime = (dtStr) => {
  const date = new Date(dtStr);
  if (isNaN(date.getTime())) {
    throw new InvalidDatetimeError("datetime did not parse as ISO 8601");
  }
  if (date.toISOString().startsWith("-")) {
    throw new InvalidDatetimeError("datetime normalized to a negative time");
  }
  if (!/^[0-9]{4}-[01][0-9]-[0-3][0-9]T[0-2][0-9]:[0-6][0-9]:[0-6][0-9](.[0-9]{1,20})?(Z|([+-][0-2][0-9]:[0-5][0-9]))$/.test(dtStr)) {
    throw new InvalidDatetimeError("datetime didn't validate via regex");
  }
  if (dtStr.length > 64) {
    throw new InvalidDatetimeError("datetime is too long (64 chars max)");
  }
  if (dtStr.endsWith("-00:00")) {
    throw new InvalidDatetimeError('datetime can not use "-00:00" for UTC timezone');
  }
  if (dtStr.startsWith("000")) {
    throw new InvalidDatetimeError("datetime so close to year zero not allowed");
  }
};
var isValidDatetime = (dtStr) => {
  try {
    ensureValidDatetime(dtStr);
  } catch (err) {
    if (err instanceof InvalidDatetimeError) {
      return false;
    }
    throw err;
  }
  return true;
};
var normalizeDatetime = (dtStr) => {
  if (isValidDatetime(dtStr)) {
    const outStr = new Date(dtStr).toISOString();
    if (isValidDatetime(outStr)) {
      return outStr;
    }
  }
  if (!/.*(([+-]\d\d:?\d\d)|[a-zA-Z])$/.test(dtStr)) {
    const date2 = new Date(dtStr + "Z");
    if (!isNaN(date2.getTime())) {
      const tzStr = date2.toISOString();
      if (isValidDatetime(tzStr)) {
        return tzStr;
      }
    }
  }
  const date = new Date(dtStr);
  if (isNaN(date.getTime())) {
    throw new InvalidDatetimeError("datetime did not parse as any timestamp format");
  }
  const isoStr = date.toISOString();
  if (isValidDatetime(isoStr)) {
    return isoStr;
  } else {
    throw new InvalidDatetimeError("datetime normalized to invalid timestamp string");
  }
};
var normalizeDatetimeAlways = (dtStr) => {
  try {
    return normalizeDatetime(dtStr);
  } catch (err) {
    if (err instanceof InvalidDatetimeError) {
      return new Date(0).toISOString();
    }
    throw err;
  }
};
var InvalidDatetimeError = class extends Error {
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ATP_URI_REGEX,
  AtUri,
  DISALLOWED_TLDS,
  DisallowedDomainError,
  INVALID_HANDLE,
  InvalidDatetimeError,
  InvalidDidError,
  InvalidHandleError,
  InvalidNsidError,
  InvalidRecordKeyError,
  InvalidTidError,
  NSID,
  ReservedHandleError,
  UnsupportedDomainError,
  ensureValidAtUri,
  ensureValidAtUriRegex,
  ensureValidDatetime,
  ensureValidDid,
  ensureValidDidRegex,
  ensureValidHandle,
  ensureValidHandleRegex,
  ensureValidNsid,
  ensureValidNsidRegex,
  ensureValidRecordKey,
  ensureValidTid,
  isValidDatetime,
  isValidHandle,
  isValidRecordKey,
  isValidTid,
  isValidTld,
  normalizeAndEnsureValidHandle,
  normalizeDatetime,
  normalizeDatetimeAlways,
  normalizeHandle
});
//# sourceMappingURL=index.js.map
